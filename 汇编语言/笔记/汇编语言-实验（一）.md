---
title: 汇编语言-实验（一）
date: 2019-04-08 11:18:40
tags: [汇编,Bug]
---

# 题目一

## 问题

在数据段DATA中有两个字数据X和Y, 假设X=1122H, Y=3344H, 编程求两个字的和,结果存放到Z单元中。

## 代码

```assembly
;*********************************************************************
data segment				; 定义数据段
	x dw 1122h				; 字 X
	y dw 3344h				; 字 Y
	z dw ?					; 字 Z
data ends
;*********************************************************************
code segment				; 定义代码段
	assume cs:code,ds:data
;---------------------------------------------------------------------	
main proc far				; 程序的主部分
start:
; 为返回DOS做准备
	push ds					; ds压栈
	xor ax,ax				; (ax) <- 0
	push ax					; ax压栈

; ds设为data
	mov ax,data				; (ax) <- data
	mov ds,ax				; (ds) <- (ax)

; z=x+y
	mov ax,x				; (ax) <- x
	add ax,y				; (ax) <- (ax)+y
	mov z,ax				; (z) <- (ax)
	
; 返回DOS环境
	ret						; 返回DOS环境
main  endp
;---------------------------------------------------------------------
code  ends
;*********************************************************************
	end start
```



# 题目二

## 问题

从SOURCE_BUFFER单元开始存放了20个字母A, 编程将这20个字母A的字符串传送到DEST_BUFFER开始的单元中。

## 代码

```assembly
;*********************************************************************
data segment					; 定义数据段
	source_buffer db 20 dup('A'); 串source_buffer，占20个字节，内容是20个字母A
data ends
;*********************************************************************
extra segment					; 定义附加段
	dest_buffer db 20 dup(?)	; 串dest_buffer，占20个字节，内容未确定
extra ends
;*********************************************************************
code segment					; 定义代码段
	assume cs:code,ds:data,es:extra
;---------------------------------------------------------------------
main proc far					; 程序的主部分
start: 
; 为返回DOS做准备
	push ds						; ds压栈
	xor ax,ax					; (ax) <- 0
	push ax						; ax压栈
	
; ds设为data
	mov ax,data					; (ax) <- data
	mov ds,ax					; (ds) <- (ax)
	
; es设为extra
	mov ax,extra				; (ax) <- extra
	mov es,ax					; (es) <- (ax)

; 准备工作
	lea si,source_buffer		; 存储源串首地址
	lea di,dest_buffer			; 存储目的串首地址
	cld							; 建立方向标志
	mov cx,20					; 20个字符
; 移动串
	rep movsb					; 移动串至CX为0，即移动整个串
	
; 返回DOS环境
	ret							; 返回DOS环境
main  endp
;---------------------------------------------------------------------
code  ends
;*********************************************************************
	end start
```

# 题目三

## 问题

从SOURCE_BUFFER单元开始存放了20个字母A, 编程将这20个字母A的字符串向下移10个单元。

## 代码

```assembly
;*********************************************************************
extra segment					; 定义附加段
	source_buffer db 20 dup('A')  ; 串source_buffer，占20个字节，内容是20个字母A
	dest_buffer EQU source_buffer+10; 串dest_buffer，结果串的首地址
extra ends
;*********************************************************************
code segment					; 定义代码段
	assume cs:code,es:extra
;---------------------------------------------------------------------
main proc far					; 程序的主部分
start: 
; 为返回DOS做准备
	push ds						; ds压栈
	xor ax,ax					; (ax) <- 0
	push ax						; ax压栈
	
; es设为extra
	mov ax,extra				; (ax) <- extra
	mov es,ax					; (es) <- (ax)
	
; 准备工作
	lea si,source_buffer+19		; 存储源串末地址
	lea di,dest_buffer+19		; 存储目的串末地址
	std							; 建立方向标志
	mov cx,20					; 20个字符
; 移动串
	rep movs es:byte ptr[di],es:[di]	; 移动串至CX为0，即移动整个串
	
; 返回DOS环境
	ret							; 返回DOS环境
main  endp
;---------------------------------------------------------------------
code  ends
;*********************************************************************
	end start
```

## BUG

不小心，上边代码写错了,`rep movs ds:byte ptr[di],ds:[di]`，源地址和目标地址不小心都用了di。

按说这样不能进行后移，但却得到了正确的结果。

经过调试，发现可能是编译环境自行将我的错误代码改成了正确代码，进行了优化。

同时也发现：`rep movs ds:byte ptr[si],ds:[di]`，这个代码也是错的，但也得到了正确的结果。

正确的代码应该是这样：`rep movs ds:byte ptr[di],ds:[si]`。



作者：[@臭咸鱼](https://github.com/chouxianyu)

转载请注明出处：<https://chouxianyu.github.io>

欢迎讨论和交流!
