---
title: 汇编语言-第五章作业
date: 2019-04-25 20:49:43
tags: [汇编]
---

# 5.6

## 题目

编写程序，将一个包含有20个数据的数组M分成两个数组：正数数组P和负数数组N，并分别把这两个数组中的数据个数显示出来。

## 流程图

```flow
flow
start=>start: 开始
getNum=>operation: 取数组下个元素
whetherNegative=>condition: 是负数？
isPositive=>operation: 存入正数数组
isNegative=>operation: 存入负数数组
whetherEnd=>condition: 数组最后一个元素？
showNegative=>operation: 显示偶数个数
showPositive=>operation: 显示奇数个数
end=>end: 结束

start->getNum->whetherNegative
whetherNegative(yes)->isNegative
whetherNegative(no)->isPositive
isNegative->whetherEnd
isPositive->whetherEnd
whetherEnd(no)->getNum
whetherEnd(yes)->showPositive->showNegative->end
```

## 程序

初始数组中存放20个数字：`1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10`

```asm
data segment
	separator0 dw 'A'		; 间隔符，方便查看内存内容
	array dw 1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10 ; 存放数组
	separator1 dw 'A'		; 间隔符，方便查看内存内容
	P dw 20 dup (?) 		; 存放正数
	separator2 dw 'A'		; 间隔符，方便查看内存内容
	N dw 20 dup (?) 		; 存放负数
	separator3 dw 'A'		; 间隔符，方便查看内存内容
	lenOfArray equ 20		; 数组长度
	lenOfP db 0 			; 存放正数的个数
	lenOfN db 0 			; 存放负数的个数
	positive db 0dh, 0ah, 'the positive number is：', '$' ; 正数的个数是：
	negative db 0dh, 0ah, 'the negative number is：', '$' ; 负数的个数是：
	crlf db 0dh, 0ah, '$'	;回车换行
data ends
; --------------------------------------------------------------------------
code segment
	main proc far
	assume cs: code, ds: data
start:

	; 为返回DOS做准备
	push ds 	; ds入栈
	sub ax, ax 	; ax置0
	push ax 	; 0入栈
	
	
	; ds存储数据段地址
	mov ax, data
	mov ds, ax 	; 给ds赋值
	
	
begin:
	mov cx, lenOfArray	; 遍历array，cx置为array的长度
	lea bx, array		; 将array存入bx
	lea si, P			; 将P存入si
	lea di, N			; 将N存入di

	
begin1:
	mov ax, [bx]		; ax指向array数组
	cmp ax, 0 			; 判断是否为负数
	js isnegative		; 结果为负则转移至isnegative
	mov [si], ax 		; 是正数，存入正数数组
	inc lenOfP 			; 正数个数+1
	add si, 2			; si后移
	jmp short next		; 判断array数组的下一个元素
	

isnegative:
	mov [di], ax 		; 是负数，存入负数数组
	inc lenOfN 			; 负数个数+1
	add di, 2			; di后移


next:
	add bx, 2			; bx后移
	loop begin1			; cx为0是跳出循环，运行后边的代码
	
	lea dx, positive 	; 显示正数个数
	mov al, lenOfP
	call display 		; 调显示子程序
	
	lea dx, negative 	; 显示负数个数
	mov al, lenOfN
	call display 		; 调显示子程序
	
	ret
	main endp
	; --------------------------------------------------------------------------
	display proc near 	; 显示子程序
	mov ah, 9 			; 调用9号DOS功能，显示一个字符串
	int 21h				; DOS系统功能调用
	aam 				; 将(al)中的二进制数转换为二个非压缩bcd码
	add ah, ‘0’ 		; 变为 0～9 的 ASCII 码
	mov dl, ah
	

	mov ah, 2 			; 调用2号DOS功能，显示一个字符
	int 21h
	add al, ‘0’ 		; 变为 0～9 的ASCII码
	mov dl, al
	

	mov ah, 2 			; 调用2号DOS功能，显示一个字符
	int 21h
	lea dx, crlf 		; 显示回车换行
	mov ah, 9 			; 调用9号DOS功能，显示一个字符串
	int 21h
	
	ret
	display endp 		; 显示子程序结束
code ends 				; 以上定义代码段
; --------------------------------------------------------------------------
end start
```

## 结果

![数组分正负1.png](https://i.loli.net/2019/04/25/5cc1ac17759f4.png)

![数组分正负2.png](https://i.loli.net/2019/04/25/5cc1ac17074fd.png)

# 5.7

## 题目

试编写一个汇编语言程序，求出首地址为array的100D字数组中的最小偶数，并把它存放在AX中。

## 程序

```assembly
data segment
	array dw 100 dup(?)
data ends
; --------------------------------------------------------------------------
code segment
	main proc far
	assume cs: code, ds: data
start:
	; 为返回DOS做准备
	push ds 		; ds入栈
	sub ax, ax 		; ax置0
	push ax 		; 0入栈
	
	
	; ds存储数据段地址
	mov ax, data
	mov ds, ax 		; 给ds赋值

	
begin:
	mov bx, 0
	mov cx, 100
	
	
compare:
	mov ax, data[bx]; 取数组的第一个数
	add bx, 2
	test ax, 01h 	; 是偶数吗？
	loopnz compare 	; 不是，则比较下一个数
	jnz stop 		; 没有偶数，退出
	jcxz stop 		; 最后一个数是偶数，即为最小偶数，退出
	

compare1:
	mov dx, data[bx]; 取数组的下一个数
	add bx, 2
	test dx, 01h 	; 是偶数吗？
	jnz next 		; 不是，比较下一个数
	cmp ax, dx 		; (ax)<(dx)吗？
	jle next
	mov ax, dx 		; (ax)<(dx)，则置换(ax)为最小偶数

	
next:
	loop compare1


stop:
	ret
main endp
code ends 				; 以上定义代码段
; --------------------------------------------------------------------------
end start
```

# 5.12

## 题目

有一个首地址为MEM的100D字数组，试编制程序删除数组中所有为0的项，并将后续项向前压缩，最后将数组的剩余部分补上0。

## 程序

```assembly
data segment
	mem dw 100 dup (?)
data ends
; --------------------------------------------------------------------------
code segment
	main proc far
	assume cs: code, ds: data
start:
	; 为返回DOS做准备
	push ds 				; 设置返回 dos
	sub ax, ax
	push ax
	
	; ds指向代码段
	mov ax, data
	mov ds, ax 				; 给ds赋值
	
begin:
	mov si, (100-1)*2 		; (si)指向 mem 的末元素的首地址
	mov bx, -2 				; 地址指针的初值
	mov cx, 100
	
comp: add bx, 2
	cmp mem [bx], 0
	jz cons
	loop comp
	jmp finish 				; 比较结束，已无0，则结束
	
cons:
	mov di, bx
	
cons1:
	cmp di, si 				; 到了最后单元吗？
	jae nomov
	mov ax, mem [di+2] 		; 后面的元素向前移位
	mov mem [di], ax
	add di, 2
	jmp cons1
	
nomov:
	mov word ptr [si], 0	; 最后单元补 0
	loop comp
	
finish:
	ret
main endp
code ends ; 以上定义代码段
; --------------------------------------------------------------------------
end start
```



作者：[@臭咸鱼](https://github.com/chouxianyu)

转载请注明出处：<https://chouxianyu.github.io>

欢迎讨论和交流!